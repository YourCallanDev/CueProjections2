/* CueProjections Prototype app.js
   UI-only demo that supports:
   - Show Maker with cue list + drag & drop (SortableJS)
   - Cue editor + asset manager
   - Control Panel with full cue list, preview, GO/Back/Blackout double-click
   - Viewer windows (multi-viewer), viewer starts with colourgrid.png
   - Many transition classes implemented via CSS
   - Export / Import show JSON
   - Preload simulation, rehearsal mode toggle
*/

// ---------- Fake storage (in-memory) ----------
const store = {
  shows: {},
  assets: {}, // assetId -> { id, filename, downloadURL, size, mime }
  viewers: [], // open viewer windows
  users: [{ id: 'callan', name: 'Callan (admin)' }]
};

const defaultShowId = createExampleShow();

function createExampleShow() {
  const id = `show-${Date.now()}`;
  const cues = [
    { id: 'c0', index: 0, title: 'Blank', type: 'color', color: '#000000', transition: 'cut', notes: '' },
    { id: 'c1', index: 1, title: 'Intro Image', type: 'image', assets: [{ id: 'a1' }], transition: 'fade2', notes: 'House lights dim' },
    { id: 'c2', index: 2, title: 'Logo', type: 'image', assets: [{ id: 'a2' }], transition: 'slideRight', notes: '' },
    { id: 'c3', index: 3, title: 'Show Reel (video)', type: 'video', assets: [{ id: 'a3' }], transition: 'dissolve', autoplay: true, loop: true, notes: 'Full-screen video' },
    { id: 'c4', index: 4, title: 'Dip to Black', type: 'color', color: '#000000', transition: 'fade5', notes: 'Long fade' },
  ];
  // assets (use placeholders; user will upload real ones)
  store.assets['a1'] = { id: 'a1', filename: '1.png', downloadURL: 'assets/1.png', size: 1024, mime: 'image/png' };
  store.assets['a2'] = { id: 'a2', filename: '2.png', downloadURL: 'assets/2.png', size: 2048, mime: 'image/png' };
  store.assets['a3'] = { id: 'a3', filename: 'walk.mp4', downloadURL: 'assets/walk.mp4', size: 1024 * 1024, mime: 'video/mp4' };

  store.shows[id] = {
    id,
    title: 'RigCheck Demo',
    description: 'Demo show generated by prototype',
    defaultTransition: 'fade2',
    cues: cues.map(c => ({ ...c })),
    assets: ['a1', 'a2', 'a3']
  };
  return id;
}

// Helper to generate IDs
function uid(prefix='id'){ return prefix + Math.random().toString(36).slice(2,9); }

// ---------- Boot ----------
// Page controls
const pages = Array.from(document.querySelectorAll('.nav-btn'));
pages.forEach(btn => btn.addEventListener('click', () => {
  document.querySelectorAll('.nav-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  const p = btn.dataset.page;
  showPage(p);
}));

function showPage(name){
  document.querySelectorAll('.page').forEach(s=>s.classList.add('hidden'));
  document.getElementById(`page-${name}`).classList.remove('hidden');
  // special handling
  if (name === 'control') refreshControlCues();
}

// UI elements
const showsList = document.getElementById('showsList');
const cueListEl = document.getElementById('cueList');
const controlShowSelect = document.getElementById('controlShowSelect');
const controlCueList = document.getElementById('controlCueList');
const currentPreview = document.getElementById('currentPreview');
const cueEditor = document.getElementById('cueEditor');
const assetGrid = document.getElementById('assetGrid');
const rehearsalToggle = document.getElementById('rehearseToggle');

// initial render
renderShows();
selectShow(defaultShowId);

// ---------- Show Maker functionality ----------
document.getElementById('btnNewShow').addEventListener('click', () => {
  const title = document.getElementById('newShowTitle').value || 'Untitled Show';
  const id = uid('show-');
  store.shows[id] = { id, title, description:'', defaultTransition:'fade2', cues:[], assets:[] };
  renderShows();
  selectShow(id);
});
document.getElementById('btnExportShow').addEventListener('click', exportCurrentShow);
document.getElementById('importShowFile').addEventListener('change', (e)=> {
  const f = e.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = ()=> {
    try {
      const payload = JSON.parse(r.result);
      const id = uid('show-');
      store.shows[id] = { id, title: payload.meta?.title || 'Imported', defaultTransition: payload.meta?.defaultTransition || 'fade2', cues: payload.cues || [], assets: payload.assets || [] };
      renderShows(); selectShow(id);
      alert('Imported show. (Note: assets referenced remain placeholders; upload real assets in Asset Manager.)');
    } catch(err){ alert('Invalid JSON'); }
  };
  r.readAsText(f);
});

// Show settings save
document.getElementById('saveShowSettings').addEventListener('click', () => {
  const id = currentShowId();
  const title = document.getElementById('showTitleInput').value;
  const def = document.getElementById('defaultTransition').value;
  if(!id) return;
  store.shows[id].title = title;
  store.shows[id].defaultTransition = def;
  renderShows();
  alert('Saved show settings');
});

// Add cues
document.getElementById('btnAddImage').addEventListener('click', ()=> addCueOfType('image'));
document.getElementById('btnAddVideo').addEventListener('click', ()=> addCueOfType('video'));
document.getElementById('btnAddColor').addEventListener('click', ()=> addCueOfType('color'));
document.getElementById('btnAddText').addEventListener('click', ()=> addCueOfType('text'));

document.getElementById('uploadAsset').addEventListener('change', (e) => {
  const f = e.target.files[0];
  if(!f) return;
  // simulate upload: create local asset with object URL
  const id = uid('a');
  const url = URL.createObjectURL(f);
  store.assets[id] = { id, filename: f.name, downloadURL: url, size: f.size, mime: f.type };
  const sId = currentShowId();
  if(sId) {
    store.shows[sId].assets = store.shows[sId].assets || [];
    store.shows[sId].assets.unshift(id);
  }
  renderAssets();
  alert('Asset uploaded (local simulate). For real app we will upload to Storage.');
});

// drag & drop via SortableJS on cueList
let sortableCueList = null;
function enableCueListDrag() {
  if(sortableCueList) try{ sortableCueList.destroy(); }catch(e){}
  sortableCueList = Sortable.create(cueListEl, {
    animation: 150, handle: '.drag-handle',
    onEnd: (evt) => {
      const newOrder = Array.from(cueListEl.children).map(li => li.dataset.id);
      const sId = currentShowId();
      if(!sId) return;
      const newCues = newOrder.map(id => store.shows[sId].cues.find(c=>c.id===id));
      // reindex
      newCues.forEach((c,i)=>c.index=i);
      store.shows[sId].cues = newCues;
      renderCueList();
    }
  });
}

function addCueOfType(type) {
  const sId = currentShowId();
  if(!sId) { alert('Create or select a show first'); return; }
  const template = { id: uid('c'), index: store.shows[sId].cues.length, title: `${type} cue`, type, transition: store.shows[sId].defaultTransition || 'fade2', notes:'', assets:[] };
  if(type === 'color') template.color = '#000000';
  store.shows[sId].cues.push(template);
  renderCueList();
  selectCue(template.id);
}

function renderShows() {
  showsList.innerHTML = '';
  controlShowSelect.innerHTML = '';
  Object.values(store.shows).forEach(s => {
    const li = document.createElement('li');
    li.textContent = s.title || s.id;
    li.className = (s.id===currentShowId()) ? 'active' : '';
    li.addEventListener('click', ()=> selectShow(s.id));
    showsList.appendChild(li);

    const opt = document.createElement('option'); opt.value = s.id; opt.textContent = s.title || s.id;
    controlShowSelect.appendChild(opt);
  });
  // reflect default selection
  if(!currentShowId()) {
    const first = Object.keys(store.shows)[0];
    if(first) selectShow(first);
  }
}

function currentShowId() {
  return window._selectedShowId || null;
}
function selectShow(id) {
  window._selectedShowId = id;
  renderShows();
  const s = store.shows[id];
  if(!s) return;
  document.getElementById('showTitleInput').value = s.title;
  document.getElementById('defaultTransition').value = s.defaultTransition || 'fade2';
  renderCueList();
  renderAssets();
}

// Cue list rendering
function renderCueList(){
  const sId = currentShowId(); if(!sId) return;
  const cues = store.shows[sId].cues || [];
  cues.sort((a,b)=>a.index-b.index);
  cueListEl.innerHTML = '';
  cues.forEach(cue => {
    const li = document.createElement('li'); li.className = 'cue-row'; li.dataset.id = cue.id;
    li.innerHTML = `
      <span class="drag-handle">☰</span>
      <img class="cue-thumb" src="${(cue.assets && cue.assets[0]) ? (store.assets[cue.assets[0].id||cue.assets[0]].downloadURL) : 'assets/colourgrid.png'}" />
      <div class="cue-meta">
        <div class="cue-index">#${cue.index}</div>
        <div class="cue-title">${cue.title}</div>
        <div class="cue-type">${cue.type}</div>
      </div>
      <div class="cue-actions">
        <button class="edit-btn">Edit</button>
        <button class="delete-btn">Delete</button>
      </div>
    `;
    // events
    li.querySelector('.edit-btn').addEventListener('click', ()=> { selectCue(cue.id); showPage('showmaker'); });
    li.querySelector('.delete-btn').addEventListener('click', ()=> {
      if(confirm('Delete cue?')) {
        store.shows[sId].cues = store.shows[sId].cues.filter(x=>x.id!==cue.id);
        renderCueList();
      }
    });
    // clicking the row will ask user if they want to jump when in control panel
    li.addEventListener('dblclick', ()=> {
      // double click in the maker opens editor
      selectCue(cue.id);
    });

    cueListEl.appendChild(li);
  });
  enableCueListDrag();
  // refresh control cuelist if open
  renderControlCueList();
}

// select a cue to edit
function selectCue(cueId){
  const sId = currentShowId();
  const cue = store.shows[sId].cues.find(c=>c.id===cueId);
  if(!cue) return;
  renderCueEditor(cue);
}

// cue editor composition
function renderCueEditor(cue) {
  cueEditor.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.innerHTML = `
    <label>Title <input id="editorTitle" value="${escapeHtml(cue.title||'')}" /></label>
    <label>Type <select id="editorType">
      <option ${cue.type==='image'?'selected':''} value="image">Image</option>
      <option ${cue.type==='video'?'selected':''} value="video">Video</option>
      <option ${cue.type==='text'?'selected':''} value="text">Text</option>
      <option ${cue.type==='color'?'selected':''} value="color">Color</option>
    </select></label>
    <label>Transition <select id="editorTransition">
      <option ${cue.transition==='cut'?'selected':''} value="cut">Cut</option>
      <option ${cue.transition==='fade2'?'selected':''} value="fade2">Fade (2s)</option>
      <option ${cue.transition==='fade5'?'selected':''} value="fade5">Fade (5s)</option>
      <option ${cue.transition==='crossfade'?'selected':''} value="crossfade">Crossfade</option>
      <option ${cue.transition==='slideRight'?'selected':''} value="slideRight">Slide Right</option>
      <option ${cue.transition==='slideLeft'?'selected':''} value="slideLeft">Slide Left</option>
      <option ${cue.transition==='slideUp'?'selected':''} value="slideUp">Slide Up</option>
      <option ${cue.transition==='slideDown'?'selected':''} value="slideDown">Slide Down</option>
      <option ${cue.transition==='zoomIn'?'selected':''} value="zoomIn">Zoom In</option>
      <option ${cue.transition==='zoomOut'?'selected':''} value="zoomOut">Zoom Out</option>
      <option ${cue.transition==='flip'?'selected':''} value="flip">Flip</option>
      <option ${cue.transition==='blur'?'selected':''} value="blur">Blur</option>
      <option ${cue.transition==='rotate'?'selected':''} value="rotate">Rotate</option>
      <option ${cue.transition==='pixelate'?'selected':''} value="pixelate">Pixelate</option>
      <option ${cue.transition==='wipe'?'selected':''} value="wipe">Wipe</option>
      <option ${cue.transition==='dissolve'?'selected':''} value="dissolve">Dissolve</option>
    </select></label>
    <label>Notes <textarea id="editorNotes">${escapeHtml(cue.notes||'')}</textarea></label>
    <div id="editorAssets">Assets:</div>
    <div class="editor-actions" style="margin-top:8px">
      <button id="saveCueBtn">Save</button>
      <button id="duplicateCueBtn">Duplicate</button>
    </div>
  `;
  cueEditor.appendChild(wrap);

  // render available assets to toggle
  const assetsDiv = document.getElementById('editorAssets');
  assetsDiv.innerHTML = '';
  const agrid = document.createElement('div'); agrid.className='asset-grid';
  Object.values(store.assets).forEach(a => {
    const card = document.createElement('div'); card.className='asset-card';
    card.innerHTML = `<img src="${a.downloadURL}" /><div><div>${a.filename}</div><small>${Math.round(a.size/1024)} KB</small></div>`;
    if(cue.assets && cue.assets.find(x => (x.id||x) === a.id)) card.style.outline = '2px solid var(--accent)';
    card.addEventListener('click', ()=> {
      cue.assets = cue.assets || [];
      const idx = cue.assets.findIndex(x => (x.id||x) === a.id);
      if(idx >= 0) cue.assets.splice(idx,1);
      else cue.assets.push({ id: a.id });
      renderCueEditor(cue);
    });
    agrid.appendChild(card);
  });
  assetsDiv.appendChild(agrid);

  // handlers
  document.getElementById('saveCueBtn').addEventListener('click', ()=> {
    cue.title = document.getElementById('editorTitle').value;
    cue.type = document.getElementById('editorType').value;
    cue.transition = document.getElementById('editorTransition').value;
    cue.notes = document.getElementById('editorNotes').value;
    // update store (already mutated)
    renderCueList();
    renderControlCueList();
    alert('Cue saved (local demo)');
  });
  document.getElementById('duplicateCueBtn').addEventListener('click', ()=> {
    const sId = currentShowId();
    const clone = JSON.parse(JSON.stringify(cue));
    clone.id = uid('c'); clone.index = store.shows[sId].cues.length;
    store.shows[sId].cues.push(clone);
    renderCueList();
    alert('Cue duplicated');
  });
}

// assets render
function renderAssets(){
  assetGrid.innerHTML = '';
  Object.values(store.assets).forEach(a => {
    const card = document.createElement('div'); card.className = 'asset-card';
    card.innerHTML = `<img src="${a.downloadURL}" /><div style="margin-left:8px"><div>${a.filename}</div><small>${Math.round(a.size/1024)} KB</small></div>`;
    assetGrid.appendChild(card);
  });
}

// ---------- Control Panel ----------
function renderControlCueList(){
  const sId = controlShowSelect.value || currentShowId();
  controlCueList.innerHTML = '';
  if(!sId) return;
  const cues = store.shows[sId].cues || [];
  cues.sort((a,b)=>a.index-b.index);
  cues.forEach(c => {
    const li = document.createElement('li'); li.className = 'control-cue-row'; li.dataset.id = c.id;
    li.innerHTML = `<div>${c.index} • ${c.title}</div><div><button class="jump">Jump</button></div>`;
    li.querySelector('.jump').addEventListener('click', ()=> {
      if(confirm(`Go to cue ${c.index}: ${c.title}?`)) {
        fireCue(sId, c.index);
      }
    });
    controlCueList.appendChild(li);
  });
}

// control buttons
document.getElementById('prevCueBtn').addEventListener('click', ()=> controlPrev());
document.getElementById('goCueBtn').addEventListener('click', ()=> controlGo());
let controlState = { showId: currentShowId(), currentIndex: 0, isBlackout:false, blackoutTimer:null };
function refreshControlCues(){
  // sync show select
  const sId = currentShowId();
  if(sId) controlShowSelect.value = sId;
  renderControlCueList();
}
controlShowSelect.addEventListener('change', ()=> refreshControlCues());

function controlPrev(){
  const sId = controlShowSelect.value || currentShowId();
  const cues = (store.shows[sId].cues||[]).sort((a,b)=>a.index-b.index);
  controlState.currentIndex = Math.max(0, (controlState.currentIndex||0)-1);
  fireCue(sId, controlState.currentIndex);
}
function controlGo(){
  const sId = controlShowSelect.value || currentShowId();
  const cues = (store.shows[sId].cues||[]).sort((a,b)=>a.index-b.index);
  const idx = Math.min(cues.length-1, (controlState.currentIndex||0)+1);
  controlState.currentIndex = idx;
  fireCue(sId, idx);
}

// blackout button — requires double-click to toggle off (safety)
const blackoutBtn = document.getElementById('blackoutBtn');
let blackoutArm = false;
blackoutBtn.addEventListener('click', ()=> {
  if(!blackoutArm){
    blackoutArm = true;
    blackoutBtn.textContent = 'Double click to confirm';
    blackoutBtn.style.opacity = '0.9';
    setTimeout(()=> { blackoutArm = false; blackoutBtn.textContent = 'Blackout'; }, 1400);
    return;
  } else {
    toggleBlackout();
    blackoutArm = false;
    blackoutBtn.textContent = 'Blackout';
  }
});
function toggleBlackout(){
  controlState.isBlackout = !controlState.isBlackout;
  broadcastToViewers({ blackout: controlState.isBlackout });
  if(controlState.isBlackout) {
    currentPreview.innerHTML = '<div style="color:#fff">BLACKOUT</div>';
  } else {
    currentPreview.innerHTML = '';
  }
}

// End show
document.getElementById('endShowBtn').addEventListener('click', () => {
  const sId = controlShowSelect.value || currentShowId();
  controlState.currentIndex = 0;
  fireCue(sId, 0);
});

// Viewer opening
document.querySelectorAll('[data-page="viewer"]').forEach(()=>{});
document.getElementById('openMultiViewer').addEventListener('click', ()=> openViewers(2));
document.getElementById('openManyViewers').addEventListener('click', ()=> openViewers(4));

// open n viewers: they all display same content in this demo
function openViewers(n = 1){
  // close existing
  store.viewers.forEach(w => { try { w.close(); } catch(e){} });
  store.viewers = [];
  for(let i=0;i<n;i++){
    const w = window.open('viewer.html','viewer'+i,'toolbar=no,location=no,status=no,menubar=no,width=1024,height=600');
    // for this static demo we create the viewer as a popup to a small inline viewer page
    // if popup blocked, create a local iframe fallback
    if(!w) {
      alert('Popup blocked — allow popups for this site to open viewer windows.');
      return;
    }
    store.viewers.push(w);
  }
  // give them a moment to load, then send current colourgrid
  setTimeout(()=> {
    broadcastToViewers({ cue: 'assets/colourgrid.png', transition: 'cut', blackout:false });
  }, 400);
}

// broadcast to viewers
function broadcastToViewers(msg){
  if(store.viewers.length === 0) {
    // attempt to open one viewer inline if none
    try { openViewers(1); } catch(e) {}
  }
  store.viewers.forEach(w => {
    try{ w.postMessage(msg, '*'); }catch(e){}
  });
  // also update the preview on control panel
  updatePreviewBox(msg);
}

// fire a cue by index on a show
function fireCue(showId, index){
  const s = store.shows[showId];
  if(!s) return;
  const cues = s.cues.sort((a,b)=>a.index-b.index);
  const cue = cues[index];
  if(!cue) return;
  controlState.currentIndex = index;
  // preload simulation: mark as preloading then send
  simulatePreload(cue);
  // broadcast
  const payload = cueToPayload(cue);
  broadcastToViewers(payload);
  highlightControlCue(index);
}

// convert cue to viewer payload (resolve asset URLs)
function cueToPayload(cue){
  const payload = { transition: cue.transition || 'fade2', autoplay: cue.autoplay||false, loop: cue.loop||false, blackout:false };
  if(cue.type === 'image') payload.cue = (cue.assets && cue.assets[0]) ? store.assets[cue.assets[0].id].downloadURL : 'assets/colourgrid.png';
  if(cue.type === 'video') payload.cue = (cue.assets && cue.assets[0]) ? store.assets[cue.assets[0].id].downloadURL : '';
  if(cue.type === 'color') payload.cue = null, payload.color = cue.color || '#000';
  if(cue.type === 'text') payload.text = cue.title || '';
  return payload;
}

// update preview
function updatePreviewBox(msg){
  currentPreview.innerHTML = '';
  if(msg.blackout){
    currentPreview.textContent = 'BLACKOUT';
    return;
  }
  if(msg.cue){
    if(msg.cue.toLowerCase().endsWith('.mp4')){
      const v = document.createElement('video'); v.src=msg.cue; v.muted=true; v.autoplay=true; v.loop=true; v.style.maxWidth='100%';
      currentPreview.appendChild(v);
    } else {
      const img = document.createElement('img'); img.src = msg.cue; currentPreview.appendChild(img);
    }
  } else if(msg.color){
    const div = document.createElement('div'); div.style.width='100%'; div.style.height='100%'; div.style.background=msg.color; currentPreview.appendChild(div);
  } else if(msg.text){
    const el = document.createElement('div'); el.style.padding='18px'; el.style.color='#fff'; el.textContent = msg.text; currentPreview.appendChild(el);
  }
}

// control list highlight
function highlightControlCue(index){
  Array.from(controlCueList.children).forEach((li,i)=> {
    li.classList.toggle('active', i === index);
  });
}

// Preload simulation
function simulatePreload(cue){
  // show a small preloading overlay for a short time before firing (if asset exists)
  // in this demo it's instant, but we simulate with a tiny delay for video
  if(cue.type === 'video') {
    // fake warm-up
    // (We still broadcast immediately to viewer in this demo)
  }
}

// ---------- Viewer message handling (pages viewer.html will include its own code for real viewer) ----------
// For prototyping we open actual viewer windows to viewer.html which is a simple file included below.
// The viewer windows listen for postMessage events and apply transition classes.
// We'll create viewer.html content dynamically on first open so the user doesn't need a separate file:
// But since cross-files are easier, instruct user to create viewer.html from template below (see instructions at end).

// ---------- Utility and helpers ----------
function renderControlCueList(){
  // sync options
  controlShowSelect.innerHTML = '';
  Object.values(store.shows).forEach(s => {
    const opt = document.createElement('option'); opt.value = s.id; opt.textContent = s.title; controlShowSelect.appendChild(opt);
  });
  // fill cue list for the currently selected show in the control panel
  const sId = controlShowSelect.value || currentShowId();
  controlCueList.innerHTML='';
  if(!sId) return;
  const cues = (store.shows[sId].cues || []).slice().sort((a,b)=>a.index-b.index);
  cues.forEach(c => {
    const li = document.createElement('li'); li.className = 'control-cue-row';
    li.innerHTML = `<div>${c.index} • ${c.title}</div><div><button class="jump">Jump</button></div>`;
    li.querySelector('.jump').addEventListener('click', ()=> {
      if(confirm(`Go to cue ${c.index}: ${c.title}?`)) fireCue(sId,c.index);
    });
    controlCueList.appendChild(li);
  });
}

// export current show JSON
function exportCurrentShow(){
  const sId = currentShowId(); if(!sId) return alert('No show selected');
  const s = store.shows[sId];
  const payload = { meta: { title: s.title, defaultTransition: s.defaultTransition }, cues: s.cues, assets: s.assets || [] };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${s.title||s.id}.json`; a.click(); URL.revokeObjectURL(url);
}

// small helper to escape
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }

// initial calls
renderAssets();
renderCueList();
renderControlCueList();
enableCueListDrag();

// showmaker navigation helper
function showPage(p){ document.querySelectorAll('.page').forEach(x=>x.classList.add('hidden')); document.getElementById('page-'+p).classList.remove('hidden'); document.querySelectorAll('.nav-btn').forEach(b=>b.classList.toggle('active', b.dataset.page===p)); if(p==='control') renderControlCueList(); }

// mock viewer.html creation instructions:
// Save the viewer.html file provided in the instructions below into the same folder as index.html.
// The viewer listens for postMessages from the controller and applies transitions on the media it receives.

console.log('CueProjections Prototype loaded. Use the Show Maker to edit cues, then open viewers and try GO/Back/Blackout.');
